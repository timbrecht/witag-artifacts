#include <stdio.h>
#include <assert.h>
#include <stdlib.h>
#include <stdbool.h>
#include <unistd.h>
#include <strings.h>
#include <regex.h>        
#include <limits.h>        
#include "cqueue.h"

const bool dbg = false;
const bool dbg_pkt = false;
const bool dbg_pre_post = false;

#define MAX_LEN             (80)
#define NUM_VALUES           (8)
#define MAX_WINDOW_SIZE    (800)
#define STATUS_MATCH        (-1)
#define STATUS_NO_MATCH     (-2)
#define STATUS_UNUSED       (-3)
#define STATUS_NOT_PACKET   (-4)
#define VALUE_INVALID       (-1)
#define REG_MATCH            (0)
#define MAX_PACKET_REGEXES  (80)
#define MIN_ZEROS            (4)

#define DEFAULT_REGEX_INDEX  (2)

#define MIN_BITMAP_LEN      (29)

#define PREAMBLE_STRING     "100"
#define POSTAMBLE_STRING    "001"

#define ZEROS_BEFORE_THOLD   (3)
#define ZEROS_AFTER_THOLD    (3)


void usage(char *pgm) {
  printf("Usage: %s [-n #] filename\n", pgm);
  printf("  -n # : number of consecutive packets to check\n");
  printf("  -p   : apply filter for packets first\n");
  printf("  -v   : verbose (print detailed output)\n");
  printf("  -h   : print usage\n");
  printf("  -?   : print usage\n");
}

/* These are different possibibilities for what we think might be packets */
char *packet_regexes[] =
{ /* Bit counts are not including the first and last 1's */
  /* 1... ... ... ... ...1 */
  /* 0123 456 789 012 3456 */
  /* 15 bits would be the ideal situation but we don't always get that */
  /* Middle/data bits could be 8,9 or 10 */
  /* 14 bits  */ "10{3}[0-1]{8}0{3}1",
  /* 14 bits  */ "10{3}[0-1]{9}0{2}1",
  /* 14 bits  */ "10{2}[0-1]{9}0{3}1",
  /* 14 bits  */ "10{2}[0-1]{10}0{2}1",
  // 
  /* 15 bits  */ "10{4}[0-1]{8}0{3}1",
  /* 15 bits  */ "10{3}[0-1]{8}0{4}1",
  /* 15 bits  */ "10{3}[0-1]{9}0{3}1",
  /* 15 bits  */ "10{2}[0-1]{9}0{4}1",
  /* 15 bits  */ "10{4}[0-1]{9}0{2}1",
  /* 15 bits  */ "10{2}[0-1]{10}0{3}1",
  /* 15 bits  */ "10{3}[0-1]{10}0{2}1",
  // 
  /* 16 bits  */ "10{4}[0-1]{8}0{4}1",
  /* 16 bits  */ "10{3}[0-1]{9}0{4}1",
  /* 16 bits  */ "10{4}[0-1]{9}0{3}1",
  /* 16 bits  */ "10{3}[0-1]{10}0{3}1",
  /* 16 bits  */ "10{2}[0-1]{10}0{4}1",
  /* 16 bits  */ "10{4}[0-1]{10}0{2}1",
};



#if 0
/* These are the regular expression we are trying for numbers */
char *r0[] =
{
  /* 14 bits  "10{3}[0-1]{8}0{3}1" */ 
  "10{3}[0-1]{8}0{3}1"

  /* 14 bits  */ "10{3}[0-1]{9}0{2}1"
  /* 14 bits  */ "10{2}[0-1]{9}0{3}1"
  /* 14 bits  */ "10{2}[0-1]{10}0{2}1"
};
#endif

/* These are the regular expression we are trying for numbers */
char *num_regexes_0[] =
{
  /* 0 */ "10{3,4}0{2,4}0{2,4}0{2,4}0{3,4}1",
  /* 1 */ "10{3,4}0{2,4}0{2,4}1{2,4}0{3,4}1",
  /* 2 */ "10{3,4}0{2,4}1{2,4}0{2,4}0{3,4}1",
  /* 3 */ "10{3,4}0{2,4}1{2,4}1{2,4}0{3,4}1",
  /* 4 */ "10{3,4}1{2,4}0{2,4}0{2,4}0{3,4}1",
  /* 5 */ "10{3,4}1{2,4}0{2,4}1{2,4}0{3,4}1",
  /* 6 */ "10{3,4}1{2,4}1{2,4}0{2,4}0{3,4}1",
  /* 7 */ "10{3,4}1{2,4}1{2,4}1{2,4}0{3,4}1",
};

char *num_regexes_1[] =
{
  /* 0 */ "10{3,4}0{2,3}0{2,3}0{2,3}0{3,4}1",
  /* 1 */ "10{3,4}0{2,3}0{2,3}1{2,3}0{3,4}1",
  /* 2 */ "10{3,4}0{2,3}1{2,3}0{2,3}0{3,4}1",
  /* 3 */ "10{3,4}0{2,3}1{2,3}1{2,3}0{3,4}1",
  /* 4 */ "10{3,4}1{2,3}0{2,3}0{2,3}0{3,4}1",
  /* 5 */ "10{3,4}1{2,3}0{2,3}1{2,3}0{3,4}1",
  /* 6 */ "10{3,4}1{2,3}1{2,3}0{2,3}0{3,4}1",
  /* 7 */ "10{3,4}1{2,3}1{2,3}1{2,3}0{3,4}1",
};

char *num_regexes_2[] =
{
  /* 0 */ "10{3,4}0{2,3}0{2,3}0{2,3}0{3,4}1",
  /* 1 */ "10{3,4}0{2,3}0{2,3}1{2,3}0{3,4}1",
  /* 2 */ "10{3,4}0{2,3}1{2,3}0{2,3}0{3,4}1",
  /* 3 */ "10{3,4}0{2,3}1{2,3}1{2,3}0{3,4}1",
  /* 4 */ "10{3,4}1{2,3}0{2,3}0{2,3}0{3,4}1",
  /* 5 */ "10{3,4}1{2,3}0{2,4}1{2,3}0{3,4}1",  // NOTE this is different
  /* 6 */ "10{3,4}1{2,3}1{2,3}0{2,3}0{3,4}1",
  /* 7 */ "10{3,4}1{2,3}1{2,3}1{2,3}0{3,4}1",
};

char *num_regexes_3[] =
{
  // Trying to allow for the possibility of a 1 here and there for 000
  /* 0 */ "10{3,4}1{0,1}0{2,4}1{0,1}0{2,4}1{0,1}0{2,4}1{0,1}0{3,4}1",
  /* 1 */ "10{3,4}0{2,3}0{2,3}1{2,3}0{3,4}1",
  /* 2 */ "10{3,4}0{2,3}1{2,3}0{2,3}0{3,4}1",
  /* 3 */ "10{3,4}0{2,3}1{2,3}1{2,3}0{3,4}1",
  /* 4 */ "10{3,4}1{2,3}0{2,3}0{2,3}0{3,4}1",
  /* 5 */ "10{3,4}1{2,3}0{2,4}1{2,3}0{3,4}1",  // NOTE this is different
  /* 6 */ "10{3,4}1{2,3}1{2,3}0{2,3}0{3,4}1",
  /* 7 */ "10{3,4}1{2,3}1{2,3}1{2,3}0{3,4}1",
};

char **num_regex_options[] = {
  num_regexes_0,
  num_regexes_1,
  num_regexes_2,
  num_regexes_3,
};


/* These are the expected string for each index.
 * 0 = "000", 1 = "001", etc.
 */
char *expected_str[] = 
{
  "000",
  "001",
  "010",
  "011",
  "100",
  "101",
  "110",
  "111",
};



struct match_info {
   int status;
   bool match[NUM_VALUES];
};

int expected_str_to_num(char * s) 
{
  for (int i=0; i<NUM_VALUES; i++) {
    if (strcmp(s, expected_str[i]) == 0) {
      // printf("expected_str_to_num %s = %d\n", s, i);
      return i;
    }
  }
  assert(1 == 0);
}

/* Is the index (number found) equal to the expected value */
bool is_expected(int match_index, char *expected) 
{
  assert(match_index >= 0);
  assert(match_index < NUM_VALUES);
  // if (dbg) printf("match_index = %d expected_str = %s expected = %s\n", 
  //        match_index, expected_str[match_index], expected);
  if (strcmp(expected_str[match_index], expected) == 0) {
    return true;
  } 
  return false;
}

int find_window_slot(struct match_info *w) 
{
  static int current = -1;

  current = (current + 1) % MAX_WINDOW_SIZE;
  return current;
  
#if 0
  int i = 0;

  if (num_added < MAX_WINDOW_SIZE) {  
    for (i=0; i<MAX_WINDOW_SIZE; i++) {
      if (w[i].status == STATUS_UNUSED) {
        break;
      }
    }
  } else {
    for (i=0; i<MAX_WINDOW_SIZE-1; i++) {
      w[i] = w[i+1];
    }
  }
  return i;
#endif
}
  
// Add info to window and return the location
void window_add(struct match_info *w, int index, int value, int status) {

  switch (status) {
    case STATUS_MATCH:
      w[index].status = STATUS_MATCH;
      w[index].match[value] = true;
      break;

    case STATUS_NO_MATCH:
      if (w[index].status != STATUS_MATCH) {
        w[index].status = STATUS_NO_MATCH;
      }
      w[index].match[value] = false;
      break;

    case STATUS_NOT_PACKET:
      w[index].status = status;
			for (int i=0; i<NUM_VALUES; i++) {
        w[index].match[i] = false;
			}
      break;

    default:
      fprintf(stderr, "window_add: Unhandled status = %d\n", status);
      exit(1);
      break;
  }

#if 0
  if (dbg) {
    for (int i=0; i<MAX_WINDOW_SIZE; i++) {
      printf("window[%d].status = %d\n", i, w[i].status);
      for (int j=0; j<MAX_WINDOW_SIZE; j++) {
         printf("  window[%d].match = %s\n", i, w[i].match[j] ? "Yes": "No");
      }
    }
  }
#endif
}

void count_bits(char *str, int *zeros, int *ones) 
{
  int len = strlen(str);
  for (int i=0; i<len; i++) {
    if (str[i] == '0') {
      (*zeros)++;
		} if (str[i] == '1') {
      (*ones)++;
    } else {
      assert(str[i] == '0' | str[i] == '1');
    }
	}
	return;
}

char *preamble_start(char *bitmap) 
{
  return(strstr(bitmap, PREAMBLE_STRING));
}

char *postamble_end(char *bitmap) 
{
  char *tmp = 0;
  char *cur = &bitmap[strlen(bitmap)] - strlen(POSTAMBLE_STRING);
  tmp = strstr(cur, POSTAMBLE_STRING);
  while ((tmp == NULL) && (cur >= bitmap)) {
	  if (dbg_pre_post) printf("bitmap = [%32s] cur = %s tmp = %s\n", bitmap, cur, tmp);
	  cur--;
    tmp = strstr(cur, POSTAMBLE_STRING);
	}
	assert(cur > 0);
	if (dbg_pre_post) printf("cur = %s\n", cur);
	cur = cur + strlen(POSTAMBLE_STRING) + 1;
	if (dbg_pre_post) printf("now cur = %s\n", cur);

	return cur;
}

bool too_many_leading_trailing_zeros(char *bitmap, int amble_filter_thold) 
{
	if (dbg_pre_post) printf("-------------------\n");
  char *start_estimate = preamble_start(bitmap);
	assert(start_estimate);
	if (dbg_pre_post) printf("start = %ld\n", start_estimate - bitmap);
  char *end_estimate = postamble_end(bitmap);
	if (dbg_pre_post) printf("end = %ld endstr = %s\n", end_estimate - bitmap, end_estimate);
	assert(end_estimate);
  // char *end_bitmap = &bitmap[strlen(bitmap)];
	int zeros_before_preamble = 0;
	int zeros_after_postamble = 0;

  char *c = bitmap;
  while (*c && c != start_estimate) {
	  if (*c == '0') {
	    zeros_before_preamble++;
		}
		c++;
  }
	if (dbg_pre_post) printf("bitmap = [%32s] zeros before = %d\n", bitmap, zeros_before_preamble);

	c = end_estimate;
  while (*c) {
	  if (*c == '0') {
	    zeros_after_postamble++;
		}
		c++;
  }
	if (dbg_pre_post) printf("bitmap = [%32s] zeros after = %d\n", bitmap, zeros_after_postamble);

	if ((zeros_before_preamble > amble_filter_thold) ||
	    (zeros_after_postamble > amble_filter_thold)) {
	  return true;
	}
	return false;
}

/* Returns the number of matches */
int is_packet(char *bitmap, regex_t r[], int count, int zero_thold, int amble_filter) 
{
  int retval = 0;
	int match_count = 0;
  int zeros = 0;
  int ones = 0;
  int len = strlen(bitmap);

	if (len < MIN_BITMAP_LEN) {
	  return 0;
	}

	count_bits(bitmap, &zeros, &ones);

  // Extra new filter. Some packets have lots of 0's and that causes problems. 
	if (zeros > zero_thold) {
	  return 0;
	}

  // Are there too many ones (e.g., all ones or not enough zeros for pre/post amble
  if (zeros < MIN_ZEROS) {
    return 0;
  }

  for (int i=0; i<count; i++) {
    retval = regexec(&r[i], bitmap, 0, NULL, 0);

    if (retval == REG_MATCH) {
		  if (amble_filter && too_many_leading_trailing_zeros(bitmap, amble_filter)) {
				   continue;
			} else {
		    if (dbg_pkt) printf("Match on: %s\n", packet_regexes[i]);
        match_count++;
			}
    }
  }
	if (match_count) {
	  if (dbg_pkt) printf("is_packet: returning %d bitmap = %s\n", match_count, bitmap);
	}
  return match_count;
}

int main(int argc, char *argv[]) 
{
   char line[MAX_LEN] = {0};
   char bitmap[MAX_LEN] = {0};
   char expected[MAX_LEN] = {0};
   int expected_counts[NUM_VALUES] = {0};
   int counts[MAX_LEN] = {0};
   int packet_counts[NUM_VALUES] = {0};
   int line_count = 0;
   int error_counts[MAX_LEN] = {0};
   char msgbuf[256] = {0};
   FILE *fp = NULL;
   regex_t num_regex[NUM_VALUES] = {0};
   regex_t packet_regex[MAX_PACKET_REGEXES] = {0};
   int retval = 0;
   int i = 0;
   int j = 0;
   char ch = '\0';
   int num_consecutive = 0;
   struct match_info window[MAX_WINDOW_SIZE] = {0};
   int index = 0;
   int num = 0;
   int status = STATUS_UNUSED;
   struct cqueue *cq = 0;
	 int most_freq_matched = false;
   int most_freq_correct_count = 0;
   int packet_filter = 0;
   int verbose = 0;
   int packet_count = 0;
   int expected_num = 0;
   int match_counts[NUM_VALUES] = {0};
   int got_match = 0;
   int regex_index = DEFAULT_REGEX_INDEX;
	 int is_a_packet = 0;
	 int zero_thold = INT_MAX;
	 int amble_filter = 0;

	 char **num_regexes = num_regex_options[regex_index];

   // if (dbg) printf("argc = %d\n", argc);

   for (i=0; i<argc; i++) {
     printf("%s ", argv[i]);
   }
   printf("\n");

   int num_packet_regexes = sizeof(packet_regexes) / sizeof(char *);
   assert(num_packet_regexes < MAX_PACKET_REGEXES);
   printf("Using %d packet regular expresions\n", num_packet_regexes);

   while ((ch = getopt(argc, argv, "a:z:r:h?vpn:")) != -1) {
     switch (ch) {
       case 'a':
			   // Pre and post amble filter
         amble_filter = atoi(optarg);
         break;

       case 'v':
         verbose = 1;
         break;

       case 'p':
         printf("Applying packet filters first\n");
         packet_filter = 1;
         break;

       case 'r':
         regex_index = atoi(optarg);
				 assert(regex_index >= 0);
				 assert(regex_index <= (sizeof(num_regex_options) / sizeof(char **)));
         printf("Using regex_option = %d\n", regex_index);
				 num_regexes = num_regex_options[regex_index];
         break;

       case 'n':
         num_consecutive = atoi(optarg);
         printf("Checking %d consecutive packets\n", num_consecutive);
         break;

       case 'z':
         zero_thold = atoi(optarg);
         printf("Packets with more than %d zeros will not be considered packets\n", 
				         zero_thold);
         break;

       case '?':
       case 'h':
       default:
         usage(argv[0]);
         exit(1);
     }
   }

   if (optind >= argc) {
     usage(argv[0]);
     exit(1);
   }

   if (dbg) printf("Opening file %s\n", argv[optind]);
   fp = fopen(argv[optind], "r");
   assert(fp);
   for (i=0; i<NUM_VALUES; i++) {
     // printf("%d = %s\n", i, expected_str[i]);
     counts[i] = 0;
     error_counts[i] = 0;
     expected_counts[i] = 0;
     match_counts[i] = 0;
   }

   for (i=0; i<MAX_WINDOW_SIZE; i++) {
     window[i].status = STATUS_UNUSED;
     for (j=0; j<MAX_WINDOW_SIZE; j++) {
       window[i].match[j] = false;
     }
   }

   if (num_consecutive > 0) {
     cq = cqueue_create(num_consecutive);
     assert(cq);
   }

   /* Compile the number regular expression */
   for (i=0; i<NUM_VALUES; i++) {
     retval = regcomp(&num_regex[i], num_regexes[i], REG_EXTENDED);

     if (retval) {
         fprintf(stderr, "Could not compile num_regex %d [%s]\n", i, num_regexes[i]);
         exit(1);
     }
   }

   /* Compile the packet regular expression */
   for (i=0; i<num_packet_regexes; i++) {
     retval = regcomp(&packet_regex[i], packet_regexes[i], REG_EXTENDED);

     if (retval) {
         fprintf(stderr, "Could not compile packet_regex %d [%s]\n", i, packet_regexes[i]);
         exit(1);
     }
   }

   /* Loop over all of the input */
   while (fgets(line, MAX_LEN, fp) != NULL) {

     most_freq_matched = false;
     // if (dbg) printf("%s\n", line);

     /* The file contains the block ack bitmap and the expected string */
     sscanf(line, "%s %s", bitmap, expected);
     // if (dbg) printf("%s [%s]\n", bitmap, expected);
     line_count++;
     index = line_count % MAX_WINDOW_SIZE;

     expected_num = expected_str_to_num(expected);
     assert(expected_num >= 0);
     assert(expected_num <= NUM_VALUES);
     expected_counts[expected_num]++;
     // printf("expected_counts[%d] = %d\n", expected_num, expected_counts[expected_num]);



#if 0
     if (packet_filter && !is_packet(bitmap, packet_regex, num_packet_regexes)) {
       window_add(window, index, VALUE_INVALID, STATUS_NOT_PACKET);
       continue;
     } else {
       packet_count++;
     }
#endif

     is_a_packet = 1;
		 if (packet_filter) {
        is_a_packet = is_packet(bitmap, packet_regex, num_packet_regexes, zero_thold, amble_filter);
		 } 

     if (is_a_packet) {

		   packet_counts[expected_num]++; 
       packet_count++;

			 /* Check for a match in any/all of the regular expressions */
			 for (num=0; num<NUM_VALUES; num++) {

				 got_match = 0;

				 /* Execute regular expression */
				 retval = regexec(&num_regex[num], bitmap, 0, NULL, 0);
				 if (retval == REG_MATCH) {
					 status = STATUS_MATCH;
					 got_match++;

					 if (verbose) {
						 printf("Match on line %8d: num = %d [%32s] guessed %d (%s), expected = %s",
									 line_count, num, bitmap, num, expected_str[num], expected);
					 }
					 if (is_expected(num, expected)) {
						 if (verbose) {
							 printf(" is correct\n");
						 }
						 counts[num]++;

					 } else {
						 if (verbose) {
							 printf(" is NOT correct\n");
						 }
						 error_counts[num]++;
					 }

				 } else if (retval == REG_NOMATCH) {
					 if (verbose) {
					    // printf("No match on line %d: num = %d [%s]\n", line_count, num, bitmap);
					 }
					 status = STATUS_NO_MATCH;
				 } else {
					 regerror(retval, &num_regex[num], msgbuf, sizeof(msgbuf));
					 fprintf(stderr, "Regex match failed: %s\n", msgbuf);
					 exit(1);
				 }

				 if (got_match) {
					 match_counts[num]++;
				 }

				 window_add(window, index, num, status);
			 }

			 if (!got_match && verbose) {
			   printf("No match on line %d: [%s] expected = %s\n", line_count, bitmap, expected);
			 }

		 } else {
       window_add(window, index, VALUE_INVALID, STATUS_NOT_PACKET);
		 }


     if (num_consecutive > 0) {
       cqueue_add(cq, &window[index]);
     }

     if (window[index].status == STATUS_NO_MATCH) {
       // printf("No match on line %d: num = %d [%s]\n", line_count, num, bitmap);
     }

		 if (num_consecutive > 0) {
			 if (line_count > num_consecutive) {
				 // TODO: update_stats
				 int max_freq = 0;
				 int most_freq_value = VALUE_INVALID;
				 int freq[NUM_VALUES] = {0};         
				 for (int i=0; i<num_consecutive; i++) {
						struct match_info *m = (struct match_info *) cq->items[i];
						assert(m);
						if (m->status == STATUS_MATCH) {
							for (int j=0; j<NUM_VALUES; j++) {
								if (m->match[j] == true) {
									freq[j]++;
									if (freq[j] > max_freq) {
										max_freq = freq[j];
										most_freq_value = j;
									}
								}
							}
						}
				 }
				 
				 if ((most_freq_value != VALUE_INVALID) && is_expected(most_freq_value, expected)) {
					 most_freq_correct_count++;
					 most_freq_matched = true;
				 }
				 printf("%d: most freq = %d found %d times = (%d %%) %s\n",
								 line_count, most_freq_value, max_freq,
								 (max_freq * 100 / num_consecutive),
								 (most_freq_matched ? "Correct" : "Incorrect"));

			 }
		 }

   }

   if (num_consecutive > 0) {
     printf("Freq based stats:\n");
     printf("Most freq correct = %8d out of %8d = %6.2lf%%\n",
           most_freq_correct_count, line_count - num_consecutive,
           most_freq_correct_count * 100.0 / (line_count - num_consecutive));
	 }

   /* Print the statistics. Errors are the number of times the
    * number was chosen/matched but it did not match the expected value 
    */
   printf("Line count = %d packet count = %d packet percent = %d%%\n",
           line_count, packet_count, (100 * packet_count / line_count));
   printf("%5s %8s %7s %9s %9s %7s %7s %7s %11s %8s %7s %7s\n",
          "Num", "Count", "Pkts", "Matches", "%Matches", "Correct", "Errors",
          "C+E", "Match%Corr", "Pkt%Corr", "%Count", "%Lines");
   for (i=0; i<NUM_VALUES; i++) {
     int total = 0;
     double percent = 0.0;
		 double expect_percent = 0.0;
     total = counts[i] +  error_counts[i];
     if (counts[i] + error_counts[i] > 0) {
       percent = (100.0 * counts[i] / total);
     }
		 if (expected_counts[i] != 0) {
		   expect_percent = 100.0 * counts[i] / expected_counts[i];
		 } else {

		 }
     printf("%5d %8d %7d %9d %9.2lf %7d %7d %7d %11.1lf %8.1lf %7.1lf %7.1lf\n", 
             i, 
             expected_counts[i],
             packet_counts[i],
             match_counts[i],
             100.0 * match_counts[i] / expected_counts[i],
             counts[i], error_counts[i], 
             total,
             percent,
             100.0 * counts[i] / packet_counts[i],  
             expect_percent,
             100.0 * counts[i] / line_count);
   }


  if (num_consecutive > 0) {
    cqueue_destroy(cq);
  }
}
